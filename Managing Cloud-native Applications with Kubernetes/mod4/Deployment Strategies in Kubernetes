<!-- ----------------------------------------------------------------------- -->
<!--                  strategies for updating applications                   -->
<!-- ----------------------------------------------------------------------- -->
strategies for updating applications deployed in a Kubernetes cluster. There are two main strategies discussed:

Rolling Strategy:

Updates are made gradually.
New pods are created for the updated version while the old pods remain until the new ones are ready to serve requests.
This ensures zero downtime during the update process.
Recreate Strategy:
All old pods are terminated at once before new pods are created.
This can lead to a period where no pods are available to serve requests, resulting in downtime.
This strategy is useful when the application cannot run multiple versions simultaneously.
The lecture also covers how to configure these strategies within the deployment specifications in Kubernetes, including parameters like maxSurge and maxUnavailable.

There are two main strategies for updating applications in Kubernetes:

Rolling Strategy: Updates are made gradually, allowing for zero downtime.
Recreate Strategy: All old pods are terminated at once before new pods are created, which may result in downtime.

<!-- ----------------------------------------------------------------------- -->
<!--                           real-life examples                            -->
<!-- ----------------------------------------------------------------------- -->

Example: Updating a Web Application

Scenario: Imagine you are a DevOps engineer working for an e-commerce company that has a web application serving thousands of customers daily. You need to update the application from Version 1 to Version 2 without causing downtime.

Rolling Strategy:

You decide to use the rolling update strategy.
As you deploy the new version, Kubernetes gradually replaces the old pods (Version 1) with new pods (Version 2).
For instance, if you have three replicas running Version 1, Kubernetes will:
Update Pod 1 to Version 2 while keeping Pods 2 and 3 running.
Once Pod 1 is confirmed to be ready and serving requests, Pod 2 is updated next.
This process continues until all pods are updated to Version 2.
Relevance: This strategy ensures that there is always at least one pod available to handle customer requests, resulting in zero downtime during the update.
Recreate Strategy:
In a different scenario, suppose the application has a significant change that does not support running both versions simultaneously (e.g., a major database schema change).
You opt for the recreate strategy.
When you deploy Version 2, Kubernetes immediately terminates all existing pods running Version 1.
After all old pods are destroyed, it starts creating new pods for Version 2.
Relevance: This approach may lead to a brief period where the application is not available to users, but it allows for a clean slate for the new version.

The rolling strategy is often preferred in production environments to maintain service availability, while the recreate strategy can be useful in specific situations where compatibility issues arise.

<!-- ----------------------------------------------------------------------- -->
<!--               pros and cons of each deployment strategy?                -->
<!-- ----------------------------------------------------------------------- -->
Here are the pros and cons of the two deployment strategies: rolling strategy and recreate strategy.

Rolling Strategy

Pros:

Zero Downtime: Ensures that at least some instances of the application are always available to handle requests during the update.
Gradual Rollout: Allows for monitoring of the new version's performance before fully committing to it, making it easier to roll back if issues arise.
User Experience: Provides a seamless experience for users, as they are less likely to notice any disruptions.
Cons:

Complexity: Requires the application to support running multiple versions simultaneously, which can complicate the architecture.
Resource Usage: Temporarily increases resource usage since both old and new versions run concurrently during the update.
State Management: Can be challenging if the application has shared state or persistent volumes that are not compatible with both versions.
Recreate Strategy

Pros:

Simplicity: Easier to implement since it does not require the application to support multiple versions running at the same time.
Clean Slate: Ensures that the new version starts with a fresh environment, which can be beneficial for major changes.
Faster Deployment: Can be quicker to execute since it involves stopping all old instances before starting new ones.
Cons:

Downtime: There is a period where the application is unavailable, which can negatively impact user experience and business operations.
Risk of Failure: If the new version has issues, there may be a complete service outage until the problem is resolved.
User Impact: Users may experience disruptions, especially during peak usage times, leading to potential loss of revenue or customer dissatisfaction.
Summary

Rolling Strategy is ideal for applications requiring high availability and minimal disruption, while Recreate Strategy is suitable for simpler deployments or when significant changes are made that do not support multiple versions.

<!-- ----------------------------------------------------------------------- -->
<!--                 configure maxSurge and maxUnavailable?                  -->
<!-- ----------------------------------------------------------------------- -->
maxSurge: This parameter specifies the maximum number of pods that can be created above the desired number of replicas during an update. It can be set as an absolute number or a percentage.
maxSurge: If set to 1, during an update, Kubernetes can create one additional pod beyond the desired replicas.

maxUnavailable: This parameter specifies the maximum number of pods that can be unavailable during the update process. Like maxSurge, it can also be set as an absolute number or a percentage.
maxUnavailable: If set to 1, at most one pod can be unavailable during the updat

<!-- ----------------------------------------------------------------------- -->
<!--           If both maxSurge and maxUnavailable are set to zero           -->
<!-- ----------------------------------------------------------------------- -->
If both maxSurge and maxUnavailable are set to zero in a Kubernetes deployment, the following will occur:

No Additional Pods: Setting maxSurge to zero means that during an update, Kubernetes will not create any additional pods beyond the desired number of replicas. This means that the number of running pods will remain constant during the update process.

No Unavailable Pods: Setting maxUnavailable to zero means that no pods can be unavailable during the update. This implies that all existing pods must remain operational and ready to serve requests throughout the update process.
Implications

No Downtime: While this configuration aims to prevent downtime, it can lead to a situation where the update cannot proceed if all existing pods must remain available and no new pods can be created.
Stuck Updates: If an update requires changes that necessitate the termination of existing pods (e.g., changing the container image), the deployment may become stuck, as Kubernetes cannot scale down any pods to make room for the new ones.
In summary, setting both maxSurge and maxUnavailable to zero can create a scenario where updates cannot be applied effectively, potentially leading to deployment issues.

<!-- --------------------------------------------------------------------------- -->
<!--  how k8s determines new pod is ready to receive requests in rolling update.-->
<!-- -------------------------------------------------------------------------- -->
Kubernetes determines when a new pod is ready to receive requests during a rolling update using readiness probes. Hereâ€™s how it works:

Readiness Probes: These are checks defined in the pod specification that determine if a pod is ready to handle traffic. You can configure different types of probes:

HTTP Probes: Kubernetes sends an HTTP request to a specified path and checks the response code.
TCP Probes: Kubernetes attempts to open a TCP connection to the specified port.
Exec Probes: Kubernetes runs a specified command inside the container and checks the exit status.
Configuration: You can configure readiness probes in the pod template of your deployment YAML file. For example:

readinessProbe:
  httpGet:
    path: /health
    port: 8080
  initialDelaySeconds: 5
  periodSeconds: 10
Pod Lifecycle: When a new pod is created during a rolling update:

Kubernetes starts the readiness probe checks based on the defined configuration.
If the probe succeeds (e.g., the HTTP response is 200), the pod is marked as "ready" and can start receiving traffic.
If the probe fails, the pod is not marked as ready, and traffic will not be routed to it.
Scaling Down Old Pods: Only after the new pod is marked as ready will Kubernetes scale down the old pod. This ensures that there is always at least one pod available to handle requests during the update process.
Summary

Readiness probes are essential for ensuring that new pods are fully operational before they start receiving traffic, allowing for a smooth transition during rolling updates.